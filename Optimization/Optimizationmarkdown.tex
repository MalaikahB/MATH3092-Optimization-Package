\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\PassOptionsToPackage{hyphens}{url} % url is loaded by hyperref
\usepackage[unicode=true]{hyperref}
\hypersetup{
            pdftitle={Optimization},
            pdfauthor={malaikah bashir},
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage[margin=1in]{geometry}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother


\title{Optimization}
\author{malaikah bashir}
\date{08/05/2021}

\begin{document}
\maketitle

\subsection{R Markdown}\label{r-markdown}

This is an R Markdown document. Markdown is a simple formatting syntax
for authoring HTML, PDF, and MS Word documents. For more details on
using R Markdown see \url{http://rmarkdown.rstudio.com}.

When you click the \textbf{Knit} button a document will be generated
that includes both content as well as the output of any embedded R code
chunks within the document. You can embed an R code chunk like this:

\section{load required packages}\label{load-required-packages}

library(`ggplot2') library(`plotly') library(``shiny'')

gss \textless{}- function(f, a, b, it = 10, tol = 1e-05 )\{

\section{\texorpdfstring{`Golden-section search function \#' @param f A
function that takes one argument x that is to be
optimized.}{Golden-section search function \# @param f A function that takes one argument x that is to be optimized.}}\label{golden-section-search-function-param-f-a-function-that-takes-one-argument-x-that-is-to-be-optimized.}

\section{\texorpdfstring{`The function must be strictly unimodal on the
interval {[}a, b{]}, if there is a unique value in {[}a,b{]} such that
is the minimum of f is on {[}a,b{]} \#' @param a The lower bound of the
function, in which the optimal value is larger than. This value must
also be real and
scalar.}{The function must be strictly unimodal on the interval {[}a, b{]}, if there is a unique value in {[}a,b{]} such that is the minimum of f is on {[}a,b{]} \# @param a The lower bound of the function, in which the optimal value is larger than. This value must also be real and scalar.}}\label{the-function-must-be-strictly-unimodal-on-the-interval-a-b-if-there-is-a-unique-value-in-ab-such-that-is-the-minimum-of-f-is-on-ab-param-a-the-lower-bound-of-the-function-in-which-the-optimal-value-is-larger-than.-this-value-must-also-be-real-and-scalar.}

\section{\texorpdfstring{`@param b The upper bound of the function, in
which the optimal value is smaller than. This value must also be real
and scalar. \#' @param it Number of iterations that the algorithm should
run. Default is set at
10.}{@param b The upper bound of the function, in which the optimal value is smaller than. This value must also be real and scalar. \# @param it Number of iterations that the algorithm should run. Default is set at 10.}}\label{param-b-the-upper-bound-of-the-function-in-which-the-optimal-value-is-smaller-than.-this-value-must-also-be-real-and-scalar.-param-it-number-of-iterations-that-the-algorithm-should-run.-default-is-set-at-10.}

\section{\texorpdfstring{`@param tol A tolerance level of which is used
to show that the function is convergingtowards the optimal solution. Set
at 1e-05 \#'
@export}{@param tol A tolerance level of which is used to show that the function is convergingtowards the optimal solution. Set at 1e-05 \# @export}}\label{param-tol-a-tolerance-level-of-which-is-used-to-show-that-the-function-is-convergingtowards-the-optimal-solution.-set-at-1e-05-export}

\section{\texorpdfstring{`@examples \#' \textgreater{} gss(f, 1,
5)}{@examples \# \textgreater{} gss(f, 1, 5)}}\label{examples-gssf-1-5}

\section{\texorpdfstring{`Interation number 10 \#' The subset interval
1.989217
1.996894}{Interation number 10 \# The subset interval 1.989217 1.996894}}\label{interation-number-10-the-subset-interval-1.989217-1.996894}

\section{' The estimated minimizer
1.993056}\label{the-estimated-minimizer-1.993056}

\#calculate the golden ratio golratio \textless{}- (sqrt(5) - 1)/2

\#set initial points using golden ratio c \textless{}- b - golratio * (b
- a) d \textless{}- a + golratio * (b - a)

\#evaluate the fn at the test points f\_c = f(c) f\_d = f(d) iteration =
0

min \textless{}- rep(0, length(it)) upper \textless{}- rep(0,
length(it)) lower \textless{}- rep(0, length(it))

oglower \textless{}- a ogupper \textless{}- b func \textless{}- f

while (abs(b - a) \textgreater{} tol \&\& iteration \textless{} it)\{
iteration = iteration + 1

\begin{verbatim}
if (f_d > f_c)
  # min is then smaller than d
  # let d be the new upper bound
  # let c be the upper test point
  {
  # set d as new upper bound
  b = d

  # set new upper test point
  d = c
  f_d = f_c

  #set new lower test point
  c <- b - golratio * (b - a)
  f_c = f(c)
}
else
  # min is then smaller than c
  # let c be the new lower bound
  # let d be the lower test point
  {
    # set c as new lower bound
    a = c
    #set new lower test point
    c = d
    f_c = f_d
    # set new upper test point
    d <- a + golratio * (b - a)
    f_d = f(d)
  }

#create classes for the upper interval,
#lower interval and minimum of each iteration of the algorithm

upper[iteration] =  d
lower[iteration] = c
min[iteration] = (c(c+d)/2)

golden = list(a = oglower , b = ogupper, func = func, c = c, d = d, upperinterval = upper, lowerinterval = lower, root_x = min, iteration = iteration)
class(golden) = c("golden", class(golden))
\end{verbatim}

\}

golden \} plot.golden \textless{}- function(x, \ldots{}) \{

\#create a loop for the plot of f xi \textless{}- seq(x\(a, x\)b, by =
((x\(b-x\)a)/100)) fx \textless{}- rep(0, length(xi)) for (i in
1:length(xi)) \{ fx{[}i{]} = x\$func(xi{[}i{]}) \} xy \textless{}-
setNames( data.frame(xi, fx), c(``x'', ``y'') )

\#create the plot for function f \# for(i in
1:length(x\(minimum)){  fig <- plot_ly(xy, x= ~x, y = ~y, mode = 'lines', type = 'scatter')  fig <- fig %>% add_trace(x = (x\)root\_x{[}i{]}),
y = x\(func((x\)root\_x{[}i{]})), type = `scatter')

\begin{verbatim}
 #plot( x= xi, y = fx, type = 'l', xlab = 'x', ylab = 'f(x)', main = "Golden Section Search Algorithm") +
#points(x = (x$lowerinterval[i]), y = f(x$lowerinterval[i]), pch = '|', col = 'green' )
#points(x = (x$upperinterval[i]), y = f(x$upperinterval[i]), pch = '|', col = 'green')
#points(x = (x$minimum[i]), y = x$fun((x$minimum[i])), pch = 18, col = 'blue')
\end{verbatim}

\# readline(`Press ENTER to continue\ldots{}')

\# \}

\}

gs \textless{}- gss(f,2,5)

summary.golden \textless{}- function(x,\ldots{})\{

result\_it \textless{}- setNames(
data.frame(x\(lowerinterval, x\)upperinterval, x\$root\_x),
c(``'',``Subset Interval'', ``Minimum'' ) )

cat(``Results after each iteration'', `\n') print(result\_it) \}
print.golden \textless{}- function(x,\ldots{})\{

cat( `Iteration number',
x\(iteration, '\n',  'The subset interval', c(x\)c,
x\(d), '\n',  'The estimated minimizer', (x\)c + x\$d)/ 2, `\n') \}

\section{example function for GSS}\label{example-function-for-gss}

f \textless{}- function(x)\{ return((x-2)**2) \} gs \textless{}- gss(f,
1, 5)

brents \textless{}- function(f, a, b, iteration = 20, tol = 1e-05)\{

\section{\texorpdfstring{`Brent's Method for Optimization \#' @param f A
function that takes one argument x that is to be
optimized}{Brent's Method for Optimization \# @param f A function that takes one argument x that is to be optimized}}\label{brents-method-for-optimization-param-f-a-function-that-takes-one-argument-x-that-is-to-be-optimized}

\section{\texorpdfstring{`Note that the function has to be continuous
over the interval stated and must have a Lagrange interpolating
polynomial of 2 or more \#' @param a Known as the contrapoint such that
f(a) and f(b) need to contain different signs to each other and the
interval contains the
solution.}{Note that the function has to be continuous over the interval stated and must have a Lagrange interpolating polynomial of 2 or more \# @param a Known as the contrapoint such that f(a) and f(b) need to contain different signs to each other and the interval contains the solution.}}\label{note-that-the-function-has-to-be-continuous-over-the-interval-stated-and-must-have-a-lagrange-interpolating-polynomial-of-2-or-more-param-a-known-as-the-contrapoint-such-that-fa-and-fb-need-to-contain-different-signs-to-each-other-and-the-interval-contains-the-solution.}

\section{\texorpdfstring{`@param b The current iterate of the algorithm
that is the current guess for the root of the function. \#' @param
iteration Number of iterations that the algorithm should run. Default is
set at
20.}{@param b The current iterate of the algorithm that is the current guess for the root of the function. \# @param iteration Number of iterations that the algorithm should run. Default is set at 20.}}\label{param-b-the-current-iterate-of-the-algorithm-that-is-the-current-guess-for-the-root-of-the-function.-param-iteration-number-of-iterations-that-the-algorithm-should-run.-default-is-set-at-20.}

\section{\texorpdfstring{`@param tol A tolerance level of which is used
to show that the function is convergingtowards the optimal solution.
Default is set at 1e-05 \#'
@export}{@param tol A tolerance level of which is used to show that the function is convergingtowards the optimal solution. Default is set at 1e-05 \# @export}}\label{param-tol-a-tolerance-level-of-which-is-used-to-show-that-the-function-is-convergingtowards-the-optimal-solution.-default-is-set-at-1e-05-export}

\section{\texorpdfstring{`@examples \#' \textgreater{} brents(g, 2, 5,
16)}{@examples \# \textgreater{} brents(g, 2, 5, 16)}}\label{examples-brentsg-2-5-16}

\section{\texorpdfstring{`Number of iterations 16 \#' Root
4.472153}{Number of iterations 16 \# Root 4.472153}}\label{number-of-iterations-16-root-4.472153}

\#calculate f(a) and f(b) f\_a = f(a) f\_b = f(b)

func \textless{}- f lower \textless{}- a current\_guess \textless{}- b

if(f\_a * f\_b \textgreater{}= 0)\{ return(``Signs of f(a) and f(b) must
be opposites !'') \#throws exception if root isn't bracketed \}

if(abs(f\_a) \textless{} abs(f\_b))\{ a = current\_guess b = lower f\_a
= f\_b f\_b = f\_a \} c = a \#c = largest of the upper and lower bounds
mflag = TRUE steps = 0 f\_c = f\_a value \textless{}- rep(0,
length(iteration))

while(steps \textless{} iteration \&\& abs(b - a) \textgreater{} tol )\{

\begin{verbatim}
 steps = steps + 1

 if(f_a != f_c && f_b != f_c){
  l0 = (a * f_b * f_c) / ((f_a - f_b) * (f_a - f_c))
  l1 = (b * f_a * f_c) / ((f_b - f_a) * (f_b - f_c))
  l2 = (c * f_a * f_b) / ((f_c - f_a) * (f_c - f_b))
  s = l0 + l1 + l2 #inverse quadratic interpolation
  }
 else{
   s = b - (f_b*((b - a)/ (f_b - f_a))) #secant
   }
 if ( (s < ((3*a + b)/ 4) | s > b) |
      (mflag = TRUE && (abs(s - a) >= (abs(b - c)/2))) |
      (mflag = FALSE && (abs(s - b) >= (abs(c - d)/2))) |
      (mflag = TRUE && (abs(b - c)< tol)) |
      (mflag = FALSE && (abs(c - d) < tol)) ) {
   s = (a + b)/ 2 #bisection
   mflag = TRUE
   }
 else{
   mflag = FALSE
   }
 f_s = f(s)
 d = c
 c = b
 if(f_a * f_s < 0){
   b = s
   }
 else{
   a = s
   }
 if(abs(f_a) < abs(f_b)){
   a = b
   b = a
 }
 value[steps] = c(s)
 bmethod = list(lower = lower, current_guess = current_guess, root_x = value, func = func, final_root = s, iterations = steps)
 class(bmethod) = c("BrentsMethod", class(bmethod))
}
\end{verbatim}

bmethod \} plot.BrentsMethod \textless{}- function(x, \ldots{}) \{

\#create a loop for the plot of f xi \textless{}-
seq(x\(lower-3, x\)current\_guess+3, by =
((x\(current_guess - x\)lower)/100)) fx \textless{}- rep(0, length(xi))
for (i in 1:length(xi)) \{ fx{[}i{]} = x\$func(xi{[}i{]}) \} xy
\textless{}- setNames( data.frame(xi, fx), c(``x'', ``y'') )

\#create the plot for function f fig \textless{}- plot\_ly(data =xy, x =
\textasciitilde{}x, y = \textasciitilde{}y, mode = `lines', type =
`scatter') \#for(i in
1:length(x\(root)){  fig <- fig %>% add_trace(x = x\)final\_root, y =
x\(func(x\)final\_root), mode = `marker')

\begin{verbatim}
 # points(x = (x$root[i]), y = x$func(x$root[i]), pch = 'x', col = 'red' )
\end{verbatim}

\# readline(`Press ENTER to continue\ldots{}')

\# \} fig

\} plot(bq) plot(exampbrents)

summary.BrentsMethod \textless{}- function(x,\ldots{})\{

result\_it \textless{}- setNames( data.frame(x\$root), c(``Root after
each iteration'' ) ) print(result\_it) \} print.BrentsMethod
\textless{}- function(x,\ldots{})\{

cat(`Number of iterations',
x\(iterations, '\n')  cat('Root', x\)final\_root, `\n')

\}

\section{test fn 1}\label{test-fn-1}

g \textless{}- function(x)\{ return((x**2)-20) \} bq \textless{}-
brents(g, -2, 5, 16)

\section{test 2}\label{test-2}

brentex \textless{}- function(x)\{ return((x+3)*((x+1)**2)) \}
exampbrents \textless{}- brents(brentex, -4, 4/3)

newtons \textless{}- function(f, x0, it = 20, tol = 1e-07 )\{

\#`Newton's Method \#' \#`@param f Function f that takes one variable x
\#' @param x0 The intial guess for the root of the function \#`@param it
Number of iterations the algorithm should run, default set at 10 \#'
@param tol Tolerance level, deafault set at 1e-07 \#`\#' @return root of
the function and the number of iterations ran \#`@export \#'
\#`@examples \#' \#`z \textless{}- function(x)\{ \#' return(cos(x) -
x**3 ) \#`\} \#' \#`\textgreater{} newtons(z, 0.5) \#' Number of
iteration 6 \#`Solution 0.865474 \#'

\#intial values h \textless{}- 0.0001 iteration = 0

\#set up variables for s3 methods root\_x \textless{}- rep(0,
length(it)) root\_y \textless{}- rep(0, length(it)) df\_iter
\textless{}- rep(0, length(it)) fun \textless{}- f

while (iteration != it) \{

\begin{verbatim}
#calculate y value
y = f(x0)
iteration = iteration + 1

#save each root for s3 methods
root_x[iteration] = x0[1]
root_y[iteration] = x0[2]

#calculate the differential for the algorithm
df = (f(x0+h) - f(x0))/h
#save differential of each iteration
df_iter[iteration] = df

if(abs(c(df)) < tol ){
  break
  #stop algorithm if the denominator is too small
}

#newtons function
x1 <- x0 - (y/df)
solfound = TRUE

if(abs(sum(x1 - x0)) <= tol){
  #stop algorithm when the result is within the tolerance
  solfound = TRUE
  break
}

x0 = x1 #update the value of x0 to current root value
sol = list(func = f, df = df_iter, root_x = root_x, root_y = root_y, intial_x = x0[1], intial_y = x0[2], sol = x0, it = iteration)
\end{verbatim}

\} if(solfound == TRUE )\{

\} else\{ print(`Algorithm did not converge') \} class(sol) =
c(`newtons', class(sol)) return(sol) \} plot.newtons \textless{}-
function(x, \ldots{}) \{

\#generates plotfor 2D functions if(is.na(x\$intial\_y) == TRUE)\{

\begin{verbatim}
#create a loop for the plot of f
xi <- seq(x$intial_x-5, x$intial_x+5, by = 0.01)
fx <- rep(0, length(xi))
for (i in 1:length(xi)) {
  fx[i] = x$func(xi[i])
}

#create the plot for function f
for(i in 1:length(x$x)){
  plot(xi, fx, type = 'l', xlab = 'x', ylab = 'f(x)', main = "Newton's Method") +
    points(x = (x$x[i]), y = x$func(x$x[i]), pch = 'x', col = 'red' )

  readline('Press ENTER to continue...')

}
\end{verbatim}

\} \#generates 3d plots

else\{ \#access required for 3d plotting library(plotly)

\begin{verbatim}
#create a loop for the plot of f
xi <- seq(x$intial_x-1, x$intial_x+1, by = 0.1)
yi <- seq(x$intial_y-1, x$intial_y+1, by = 0.1)
xy <- expand.grid(xi, yi)

#create list of z values using function
f_xy <- rep(0, length(xi))
for (i in 1:nrow(xy)) {
  f_xy[i] <- x$fun(xy[i,])
}
zi <- data.matrix(f_xy)

#merge all data into one data frame
plotdata <- setNames(
  data.frame(xy, zi),
  c("x", "y", "z")
)

#create the plot for function f
library(plotly)
plot_ly(plotdata, x = ~x, y = ~y, z = ~z, type="mesh3d",
        intensity = ~z,
        colorscale = 'Viridis')
\end{verbatim}

\}

\} summary.newtons \textless{}- function(x,\ldots{})\{

result\_it \textless{}- setNames( data.frame(x\(df, x\)root\_x,
x\$root\_y), c( ``Differential'',``x'', ``y'' ) )

cat(``Results after each iteration'', `\n') print(result\_it)

\} print.newtons \textless{}- function(x,\ldots{})\{

cat(`Number of iterations taken', x\(it, '\n')  cat('Solution', x\)sol,
`\n')

\}

\section{beale function}\label{beale-function}

beale \textless{}- function(x)\{ return((1.5 - x{[}1{]} +
x{[}1{]}*x{[}2{]})\textbf{2 + (2.25 - x{[}1{]} +
x{[}1{]}\emph{(x{[}2{]}\textbf{2))}2 + (2.625 - x{[}1{]} +
x{[}1{]}}(x{[}2{]}}3))**2) \} \#beale fn nra \textless{}- newtons(beale,
c(3.1,0.55))

\section{matyas function}\label{matyas-function}

matyas \textless{}- function(x)\{ return(0.26\emph{(x{[}1{]}\textbf{2 +
x{[}2{]}}2) - 0.48}x{[}1{]}*x{[}2{]} ) \} newtex \textless{}-
newtons(matyas, c(0.02, 0.05))

gradient \textless{}- function()

sgd \textless{}- function(x, y, alpha = 0.01, it = 50)\{

\#bind together x and y vectors to enable accurate sampling xy
\textless{}- data.frame(cbind(y,x)) \#set up intial theta matrix,
representing the theta \textless{}- matrix(c(0,0,0,0,0) , nrow = 1)
\#matrix to store results from each iteration alltheta \textless{}-
matrix(NA, nrow = it, ncol = 3)

set.seed(25) \#xy data sample from data samp \textless{}- as.matrix(
xy{[}sample(nrow(xy), 5, replace = TRUE), {]})

\#define the x and y sample matricies samp\_x \textless{}-
as.matrix(samp{[},2{]}) samp\_y \textless{}- as.matrix(samp{[},1{]})
for(i in 1:it)\{

\begin{verbatim}
print(samp_x)
print(theta)


#calculate the prediction value using sample data
prediction <- (1/nrow(samp_y)) * ((theta) %*% t(samp_x))

#update the theta value
theta <- theta - alpha * ((prediction) - t(samp_y))

#save the theta value
#alltheta[i,] <- theta
\end{verbatim}

\} return(theta) \} attach(mtcars) sgd(disp, mpg)

\section{\texorpdfstring{`Log-Barrier Method
\#'}{Log-Barrier Method \#}}\label{log-barrier-method}

\section{\texorpdfstring{`@param f Objective function f to which the
user is trying to solve for \#' @param cons Inequality/equality
contraints in the form such that Ax = b is Ax -
b}{@param f Objective function f to which the user is trying to solve for \# @param cons Inequality/equality contraints in the form such that Ax = b is Ax - b}}\label{param-f-objective-function-f-to-which-the-user-is-trying-to-solve-for-param-cons-inequalityequality-contraints-in-the-form-such-that-ax-b-is-ax---b}

\section{\texorpdfstring{`@param x0 Intial guess of the solution to the
optimization problem \#' @param it Number of iterations, default is set
at
10}{@param x0 Intial guess of the solution to the optimization problem \# @param it Number of iterations, default is set at 10}}\label{param-x0-intial-guess-of-the-solution-to-the-optimization-problem-param-it-number-of-iterations-default-is-set-at-10}

\section{\texorpdfstring{`@param m Highest number of dimensions in the
problem, eg. x\^{}2 + 2x would be 2 \#' @param mu multiple to increase t
by, must be greater than
1}{@param m Highest number of dimensions in the problem, eg. x\^{}2 + 2x would be 2 \# @param mu multiple to increase t by, must be greater than 1}}\label{param-m-highest-number-of-dimensions-in-the-problem-eg.-x2-2x-would-be-2-param-mu-multiple-to-increase-t-by-must-be-greater-than-1}

\section{\texorpdfstring{`@param epsilon default set at 1e-07
\#'}{@param epsilon default set at 1e-07 \#}}\label{param-epsilon-default-set-at-1e-07}

\section{\texorpdfstring{`@return \#' The solution and number of
iterations ran, can be called using the print
function}{@return \# The solution and number of iterations ran, can be called using the print function}}\label{return-the-solution-and-number-of-iterations-ran-can-be-called-using-the-print-function}

\section{\texorpdfstring{`@export \#'}{@export \#}}\label{export}

\section{\texorpdfstring{`@examples \#'}{@examples \#}}\label{examples}

\section{\texorpdfstring{' ex1 \textless{}- function(x)\{return((1 -
x{[}1{]})**2 + 100*(x{[}2{]} - x{[}1{]}\textbf{2)}2)\} \#' ex2
\textless{}- function(x)\{return((x{[}1{]} - 1)**3 - 1)\} \#`lbexample
\textless{}-logbarrier(ex1, ex2, c(1.2, 1.2), m = 2, mu = 3) \#'
print(lbexample) \#`\#' log-barrier solution 1.00001 1.00001 \#' Number
of iterations
10}{' ex1 \textless{}- function(x)\{return((1 - x{[}1{]})**2 + 100*(x{[}2{]} - x{[}1{]}2)2)\} \#' ex2 \textless{}- function(x)\{return((x{[}1{]} - 1)**3 - 1)\} \#lbexample \textless{}-logbarrier(ex1, ex2, c(1.2, 1.2), m = 2, mu = 3) \# print(lbexample) \#\# log-barrier solution 1.00001 1.00001 \#' Number of iterations 10}}\label{ex1---functionxreturn1---x12-100x2---x122-ex2---functionxreturnx1---13---1-lbexample--logbarrierex1-ex2-c1.2-1.2-m-2-mu-3-printlbexample-log-barrier-solution-1.00001-1.00001-number-of-iterations-10}

logbarrier \textless{}- function(f, cons, x0, it = 10, m, mu, epsilon =
1e-07)\{

\#intial values x\_t = x0 t = m/ epsilon iteration = 0 f = f cons = cons
root\_x \textless{}- rep(0, length(it)) root\_y \textless{}- rep(0,
length(it)) resultf \textless{}- rep(0, length(it))

\#create function of problem to be solved problem \textless{}-
function(x)\{ return(f(x) - t\emph{(log(-1}(cons(x))))) \}

while(iteration != it)\{

\begin{verbatim}
#set up iteration counter
iteration = iteration + 1

if (m/t > epsilon){
  print("Algorithm did not converge")
}

else{

  resultf[iteration] = problem(x_t)
  #use newtons method to extract the root
  newt <- newtons(problem, x_t, it = it)
  x <- newt$sol

  #update root and t value before next iteration
  x_t <- c(x)
  t <- mu * t
  root_x[iteration] = x_t[1]
  root_y[iteration] = x_t[2]

}
barrier = list(func = f, constraint = cons, intial = x0,
               x_root = root_x, y_root = root_y, sol = x_t,
               result_function = resultf, it = iteration)
class(barrier) = c('barrier', class(barrier))
\end{verbatim}

\} barrier \} plot.barrier \textless{}- function(x, \ldots{}) \{

\#generates error message for 2D functions if(is.na(x\$y\_root{[}1{]})
== TRUE)\{ return(``Plot cannot be produced, for plotting please use a
3-dimentional function'') \}

\#access required for 3d plotting library(plotly)

\#create a loop for the plot of f xi \textless{}-
seq(x\(intial[1] -3, x\)intial{[}1{]}+3, by = 0.1) yi \textless{}-
seq(x\(intial[2]-3, x\)intial{[}2{]}+3, by = 0.1) xy \textless{}-
expand.grid(xi, yi)

\#create list of z values for main function f\_xy \textless{}- rep(0,
length(xi)) for (i in 1:nrow(xy)) \{ f\_xy{[}i{]} \textless{}-
x\$func(xy{[}i,{]}) \} zi \textless{}- data.matrix(f\_xy)

\#merge all data into one data frame plotdata \textless{}- setNames(
data.frame(xy, zi), c(``x'', ``y'', ``z'') )

\#create z values for constraint function c\_xy \textless{}- rep(0,
length(xi)) for(i in 1:nrow(xy))\{ c\_xy{[}i{]} \textless{}-
x\$func(xy{[}i,{]}) \} c\_zi \textless{}- data.matrix(c\_xy) \#merge the
data for constraints together consdata \textless{}- setNames(
data.frame(xy, c\_zi), c(``x'', ``y'', ``z'') )

\#create the plot for function f library(plotly) fig \textless{}-
plot\_ly(plotdata, x = \textasciitilde{}x, y = \textasciitilde{}y, z =
\textasciitilde{}z, type=``mesh3d'', intensity = \textasciitilde{}z,
colorscale = `Viridis', opacity = 0.75) \#fig \textless{}- fig
\%\textgreater{}\% add\_trace(type = `contour', \# data = consdata, \# x
= \textasciitilde{}x, \# y = \textasciitilde{}z

\# ) fig

\} summary.barrier \textless{}- function(x,\ldots{})\{

result\_it \textless{}- setNames( data.frame(x\(x_root, x\)y\_root,
x\$result\_function), c(``x'', ``y'', ``barrier problem'') )
cat(``Result after each iteration'', `\n') print(result\_it) \}
print.barrier \textless{}- function(x,..)\{

cat(``log-barrier solution'',
x\(sol, '\n')  cat("Number of iterations", x\)it)

\}

\section{Rosenbrock function constrained to a
disk}\label{rosenbrock-function-constrained-to-a-disk}

ex1 \textless{}- function(x)\{return((1 - x{[}1{]})**2 + 100*(x{[}2{]} -
x{[}1{]}\textbf{2)}2)\} ex2 \textless{}- function(x)\{return((x{[}1{]} -
1)**3 - 1)\} lbexample \textless{}-logbarrier(ex1, ex2, c(1.2, 1.2), m =
2, mu = 3)

\section{Gomez and Levy function}\label{gomez-and-levy-function}

pt1 \textless{}- function(x)\{return(4*x{[}1{]}**2 - 2.1*x{[}1{]}**4 +
(1/3)*x{[}1{]}\textbf{6 + x{[}1{]}\emph{x{[}2{]} - 4}x{[}2{]}}2 - 1 +
x{[}2{]}**4)\} pt2 \textless{}-
function(x)\{return(sin(4\emph{pi}x{[}1{]}) +
2\emph{sin(2}pi*x{[}2{]})**2 - 1.5)\} \#logbarrier(pt1, pt2, c(0.8,
-0.7), m = 2, mu = 3)

\subsection{Including Plots}\label{including-plots}

You can also embed plots, for example:

Note that the \texttt{echo\ =\ FALSE} parameter was added to the code
chunk to prevent printing of the R code that generated the plot.

\end{document}
